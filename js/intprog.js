const intprogQuestions = [
  {q:"Which OOP concept represents 'IS-A' relationship?",a:["Encapsulation","Polymorphism","Inheritance","Abstraction"],c:2,exp:"Inheritance represents an 'IS-A' relationship where a subclass IS-A type of superclass (Dog IS-A Animal). Encapsulation bundles data, polymorphism enables multiple forms, and abstraction hides complexity."},
  {q:"Binding data and functions together is:",a:["Inheritance","Abstraction","Encapsulation","Polymorphism"],c:2,exp:"Encapsulation bundles data (fields) and methods that operate on that data within a class, hiding internal details. It's the foundation of data hiding and access control through private/public modifiers."},
  {q:"Keyword to inherit a class in Java:",a:["implements","extends","inherits","using"],c:1,exp:"The 'extends' keyword creates inheritance relationships between classes. 'implements' is for interfaces. Java doesn't use 'inherits' or 'using' for inheritance (though C++ uses 'using')."},
  {q:"Ability of object to take many forms:",a:["Polymorphism","Encapsulation","Inheritance","Abstraction"],c:0,exp:"Polymorphism allows objects to take many forms - a Dog object can be treated as both Dog and Animal. This includes method overloading (compile-time) and overriding (runtime polymorphism)."},
  {q:"Parent class is also called:",a:["Subclass","Derived class","Superclass","Child class"],c:2,exp:"The parent class is called the superclass or base class. The child that inherits from it is called the subclass or derived class. 'Super' indicates it's higher in the hierarchy."},
  {q:"Hiding internal details is:",a:["Abstraction","Inheritance","Overloading","Instantiation"],c:0,exp:"Abstraction hides complex implementation details and shows only essential features. It's achieved through abstract classes and interfaces. Encapsulation is related but focuses on bundling data with methods."},
  {q:"OOP focuses on:",a:["Functions","Logic","Data","Speed"],c:2,exp:"Object-Oriented Programming focuses on data (objects) and the operations performed on them, unlike procedural programming which focuses on functions. Objects encapsulate both data and behavior."},
  {q:"Method in subclass with same signature is:",a:["Overloading","Overriding","Hiding","Duplicating"],c:1,exp:"Method overriding occurs when a subclass provides a different implementation of a method already defined in its superclass with the same signature. This enables runtime polymorphism."},
  {q:"Multi-level inheritance example:",a:["A extends B, B extends C","A extends B and C","A is final class","No inheritance"],c:0,exp:"Multi-level inheritance forms a chain where A extends B, and B extends C (GrandChild -> Child -> Parent). This differs from multiple inheritance where a class extends multiple classes directly."},
  {q:"Java does NOT support this for classes:",a:["Single inheritance","Multi-level inheritance","Multiple inheritance","Hierarchical inheritance"],c:2,exp:"Java doesn't allow a class to extend multiple classes (multiple inheritance) to avoid the diamond problem. However, it supports multiple interface implementation and other inheritance types."},
  {q:"What is a class in Java?",a:["A function","Blueprint for objects","A variable","A loop"],c:1,exp:"A class is a blueprint or template that defines the structure (fields) and behavior (methods) of objects. Objects are instances created from classes, like building houses from blueprints."},
  {q:"What is an object?",a:["Class definition","Instance of a class","A method","A package"],c:1,exp:"An object is a specific instance of a class with actual values. If 'Car' is a class, 'myCar' with color='red' and speed=100 is an object. Classes define structure; objects have actual data."},
  {q:"'this' keyword refers to:",a:["Superclass","Current object instance","Static context","Method parameter"],c:1,exp:"'this' refers to the current instance of the class. It's used to distinguish instance variables from parameters with the same name and to call other constructors in the same class."},
  {q:"Method overloading means:",a:["Same name, different parameters","Same name in parent/child","Too many methods","Private methods only"],c:0,exp:"Method overloading allows multiple methods with the same name but different parameter lists (number, type, or order). The compiler determines which method to call based on arguments at compile-time."},
  {q:"'final' keyword on a class prevents:",a:["Instantiation","Inheritance","Execution","Declaration"],c:1,exp:"'final' classes cannot be extended (inherited from). This is used for security or design reasons when you don't want the class behavior to be modified. String is a famous final class."},
  {q:"What is a constructor?",a:["Special method to initialize object","Destructor method","Infinite loop","Primitive type"],c:0,exp:"A constructor is a special method with the same name as the class, called automatically when creating objects. It initializes object state. Unlike regular methods, constructors have no return type."},
  {q:"'super' keyword is used to:",a:["Access/call superclass members","Create new objects","Define static variables","Import packages"],c:0,exp:"'super' accesses superclass members - fields, methods, or constructors. super() calls the parent constructor and must be the first statement in a child constructor if used."},
  {q:"An interface in Java mainly contains:",a:["Concrete methods only","Abstract methods & constants","Instance variables","Constructors"],c:1,exp:"Interfaces primarily contain abstract method declarations (no body) and constants (public static final fields). Since Java 8, they can also have default and static methods with implementations."},
  {q:"'static' members belong to:",a:["Each instance","The class itself","Local scope only","Final fields only"],c:1,exp:"Static members (fields and methods) belong to the class, not individual objects. They're shared across all instances and can be accessed without creating an object using ClassName.member."},
  {q:"Compile-time polymorphism is achieved by:",a:["Method overriding","Method overloading","Inheritance only","Encapsulation"],c:1,exp:"Method overloading provides compile-time (static) polymorphism. The compiler determines which overloaded method to call based on method signature. Method overriding provides runtime (dynamic) polymorphism."},
  {q:"Which keyword is used to implement an interface?",a:["extends","implements","inherits","using"],c:1,exp:"Classes use 'implements' to implement interfaces, while they use 'extends' to inherit from other classes. A class can implement multiple interfaces but extend only one class in Java."},
  {q:"Can an abstract class have constructors?",a:["No, never","Yes","Only static constructors","Only private constructors"],c:1,exp:"Abstract classes can have constructors that are called when concrete subclasses are instantiated. These constructors initialize inherited fields. Abstract classes can't be instantiated directly, but constructors are used by subclasses."},
  {q:"Default access modifier in Java is:",a:["public","protected","private","package-private"],c:3,exp:"When no access modifier is specified, Java uses package-private (default) access. Members are accessible only within the same package. It's more restrictive than public/protected but less than private."},
  {q:"Which cannot be overridden?",a:["private methods","static methods","final methods","All of the above"],c:3,exp:"Private methods aren't visible to subclasses. Static methods are hidden, not overridden. Final methods explicitly prevent overriding. All three cannot be overridden in the traditional sense."},
  {q:"What is runtime polymorphism?",a:["Overloading","Overriding + inheritance","Static binding","Early binding"],c:1,exp:"Runtime (dynamic) polymorphism occurs through method overriding in inheritance hierarchies. The JVM determines which method implementation to call at runtime based on the actual object type, not the reference type."},
  {q:"A class can extend how many classes?",a:["Many","One","Zero","Two"],c:1,exp:"In Java, a class can extend only one class (single inheritance) to avoid the diamond problem's ambiguity. However, a class can implement multiple interfaces."},
  {q:"A class can implement how many interfaces?",a:["One","Many","Zero","Two only"],c:1,exp:"A class can implement multiple interfaces, providing a workaround for Java's lack of multiple inheritance. This allows a class to inherit abstract behavior from multiple sources."},
  {q:"What does 'has-a' relationship represent?",a:["Inheritance","Composition","Polymorphism","Abstraction"],c:1,exp:"Composition represents a 'HAS-A' relationship where one class contains another as a field (Car HAS-A Engine). Inheritance represents 'IS-A'. Composition favors flexibility over inheritance."},
  {q:"Which is used for code reuse without inheritance?",a:["Composition","Overriding","Abstract classes","Final classes"],c:0,exp:"Composition achieves code reuse by including instances of other classes as fields, without creating inheritance relationships. This provides flexibility and avoids tight coupling of inheritance hierarchies."},
  {q:"What is method hiding?",a:["Static method redefinition","Instance method overriding","Private method usage","Final method usage"],c:0,exp:"Method hiding occurs when a subclass defines a static method with the same signature as a static method in the superclass. Unlike overriding, the method called is determined by the reference type, not object type."},
  {q:"Which is true about abstract methods?",a:["Must have body","No body, must be overridden","Can be final","Can be static"],c:1,exp:"Abstract methods have no body (just signature) and must be implemented by concrete subclasses. They cannot be final (preventing override) or static (belong to class, not instances). They force subclasses to provide implementations."},
  {q:"Can interfaces have instance variables?",a:["Yes, public static final only","Yes, any type","No variables allowed","Only private"],c:0,exp:"Interfaces can only have constants (public static final variables), not true instance variables. These are implicitly public, static, and final even if not explicitly declared."},
  {q:"What is the default superclass of every class?",a:["Object","Main","Super","Base"],c:0,exp:"Every Java class implicitly extends Object (java.lang.Object) if no other superclass is specified. Object provides fundamental methods like equals(), toString(), and hashCode() inherited by all classes."},
  {q:"Which method is called by garbage collector?",a:["finalize()","destroy()","delete()","clean()"],c:0,exp:"The finalize() method is called by the garbage collector before reclaiming an object's memory. However, it's deprecated and unreliable - modern code should use try-with-resources or explicit cleanup methods instead."},
  {q:"What does 'instanceof' check?",a:["Type compatibility at runtime","Equality of objects","Reference equality","Static type"],c:0,exp:"'instanceof' is a binary operator that tests whether an object is an instance of a specific class or implements an interface at runtime. It returns true/false and is used for safe type casting."},
  {q:"Which cannot be inherited?",a:["Constructors","Static methods","Final methods","All of the above"],c:3,exp:"Constructors aren't inherited (though they can be called via super()). Static methods are hidden, not inherited. Final methods can be inherited but not overridden. All three have inheritance restrictions."},
  {q:"What is a marker interface?",a:["Interface with no methods","Interface with one method","Interface with constants only","Abstract class"],c:0,exp:"A marker (or tag) interface has no methods or fields - it just marks classes for a specific purpose. Examples: Serializable, Cloneable. Modern Java uses annotations instead."},
  {q:"Which interface is used for sorting?",a:["Comparable","Comparator","Runnable","Serializable"],c:0,exp:"Comparable interface (with compareTo method) defines natural ordering for a class. Objects implementing Comparable can be sorted automatically. Comparator provides external comparison logic."},
  {q:"What is covariant return type?",a:["Changing return type in override","Same return type always","Primitive return only","Void return only"],c:0,exp:"Covariant return types allow an overriding method to return a subtype of the return type declared in the overridden method. This provides more specific type information while maintaining compatibility."},
  {q:"Can static methods be overridden?",a:["Yes","No, they are hidden","Only in abstract classes","Only in final classes"],c:1,exp:"Static methods cannot be overridden - they are hidden instead. If a subclass defines a static method with the same signature, it hides the parent's method. The method called depends on reference type, not object type."},
  {q:"What is the purpose of @Override annotation?",a:["Force override, catch errors","Make method static","Hide method","Make method final"],c:0,exp:"@Override tells the compiler you intend to override a method. If the method doesn't actually override (wrong signature, parent method doesn't exist), the compiler generates an error, catching mistakes."},
  {q:"Which access modifier allows subclass + package access?",a:["public","protected","private","default"],c:1,exp:"'protected' allows access within the same package and by subclasses in other packages. It's more open than package-private (default) but more restrictive than public."},
  {q:"What is an inner class?",a:["Class inside another class","Static class","Top-level class","Package class"],c:0,exp:"An inner class is defined within another class. Non-static inner classes have access to the outer class's instance members and maintain a reference to the outer instance."},
  {q:"A static nested class is:",a:["Tied to instance","Independent of instance","Cannot access outer members","Always abstract"],c:1,exp:"Static nested classes don't maintain a reference to the outer class instance. They're independent and can only access static members of the outer class, making them like top-level classes scoped within another class."},
  {q:"Which is NOT a pillar of OOP?",a:["Inheritance","Polymorphism","Encapsulation","Compilation"],c:3,exp:"The four pillars of OOP are Encapsulation, Inheritance, Polymorphism, and Abstraction. Compilation is a language implementation detail, not an OOP principle."},
  {q:"What is early binding?",a:["Compile-time resolution","Runtime resolution","Dynamic dispatch","Late binding"],c:0,exp:"Early (static) binding resolves method calls at compile-time. Used for static, private, and final methods, and method overloading. The compiler knows exactly which method will be called."},
  {q:"What is late binding?",a:["Compile-time","Runtime polymorphism","Static method call","Final method call"],c:1,exp:"Late (dynamic) binding resolves method calls at runtime based on the actual object type. Used for method overriding. The JVM determines which overridden method to call during execution."},
  {q:"Can constructors be inherited?",a:["Yes","No, but can be called via super()","Only default constructor","Only private constructor"],c:1,exp:"Constructors aren't inherited because they're specific to each class. However, subclass constructors can (and must) call superclass constructors using super() to initialize the inherited portion of the object."},
  {q:"What does 'new' keyword do?",a:["Creates object","Calls constructor","Allocates memory","All of the above"],c:3,exp:"'new' allocates memory for a new object, initializes it by calling the appropriate constructor, and returns a reference to the object. All three steps occur when you use 'new'."},
  {q:"Which is a valid constructor?",a:["void ClassName()","ClassName()","private ClassName(int x)","All are valid"],c:3,exp:"Constructors can be public, private, or have parameters. private ClassName(int x) is valid (used in singleton pattern). The key: constructors have no return type, not even void."},
  {q:"What is constructor overloading?",a:["Multiple constructors with different params","Overriding constructor","Hiding constructor","Final constructor"],c:0,exp:"Constructor overloading provides multiple constructors with different parameter lists. This allows objects to be created in different ways. The compiler selects the appropriate constructor based on arguments."},
  {q:"Which keyword prevents method overriding?",a:["static","final","private","All of the above"],c:3,exp:"'final' explicitly prevents overriding. 'private' methods aren't visible to subclasses, so they can't be overridden. 'static' methods are hidden, not overridden. All three effectively prevent overriding."},
  {q:"What is a default constructor?",a:["No-arg constructor provided by compiler","User-defined no-arg constructor","Parameterized constructor","Final constructor"],c:0,exp:"The default constructor is automatically provided by the compiler if no constructors are defined. It's a no-arg constructor that calls the superclass's no-arg constructor. If you define any constructor, the default is not provided."},
  {q:"Can a class have multiple constructors?",a:["No","Yes (overloading)","Only two","Only if abstract"],c:1,exp:"A class can have multiple constructors with different parameter lists (constructor overloading). This provides flexibility in object creation, allowing various initialization methods."},
  {q:"What happens if you don't define any constructor?",a:["Compilation error","Default no-arg constructor","Runtime error","Abstract class error"],c:1,exp:"If no constructor is defined, Java automatically provides a default no-arg constructor that calls the superclass's no-arg constructor. This only happens if you define NO constructors."},
  {q:"Which is used to call parent class constructor?",a:["this()","super()","parent()","base()"],c:1,exp:"super() calls the superclass constructor and must be the first statement in a subclass constructor (if used explicitly). Every constructor calls a superclass constructor, either explicitly with super() or implicitly."},
  {q:"Can super() and this() both appear in one constructor?",a:["Yes","No, only one allowed","Only in abstract class","Only in final class"],c:1,exp:"Only one constructor call (super() or this()) can appear in a constructor, and it must be the first statement. You can't call both because each must be first, which is impossible."},
  {q:"What is the first line in a constructor usually?",a:["super() or this()","System.out.println","Variable declaration","Return statement"],c:0,exp:"Constructors typically start with super() or this() to call another constructor. If omitted, Java implicitly adds super() to call the no-arg constructor of the superclass."},
  {q:"Which method cannot be abstract?",a:["private","static","final","All of the above"],c:3,exp:"Abstract methods must be overridden, but private methods aren't visible to subclasses, static methods belong to the class (can't be overridden), and final methods can't be overridden. None can be abstract."},
  {q:"Can an interface extend another interface?",a:["No","Yes","Only one","Only multiple"],c:1,exp:"Interfaces can extend multiple other interfaces using 'extends' (not implements). This creates an interface hierarchy. A class implementing the child interface must implement all methods from the hierarchy."},
  {q:"Default methods in interface were introduced in:",a:["Java 7","Java 8","Java 9","Java 11"],c:1,exp:"Java 8 introduced default methods in interfaces - methods with implementations using the 'default' keyword. This allows adding new methods to interfaces without breaking existing implementations."},
  {q:"What is functional interface?",a:["Interface with exactly one abstract method","Interface with many methods","Abstract class","Marker interface"],c:0,exp:"A functional interface has exactly one abstract method (though it can have multiple default/static methods). They can be used with lambda expressions and method references. Example: Runnable, Callable."},
  {q:"@FunctionalInterface annotation is:",a:["Mandatory","Optional but recommended","Not allowed","Only for abstract classes"],c:1,exp:"@FunctionalInterface is optional but recommended. It tells the compiler to verify the interface has exactly one abstract method, generating an error if violated. It documents intent for other developers."},
  {q:"Which is an example of functional interface?",a:["Runnable","Comparable","Comparator","All of the above"],c:3,exp:"Runnable (one method: run), Comparable (one method: compareTo), and Comparator (one abstract method: compare, plus default methods) are all functional interfaces with exactly one abstract method."},
  {q:"What does diamond problem refer to?",a:["Multiple inheritance ambiguity","Single inheritance","Composition issue","Polymorphism issue"],c:0,exp:"The diamond problem occurs in multiple inheritance when a class inherits the same method from multiple paths, causing ambiguity about which implementation to use. Java avoids this by not allowing multiple class inheritance."},
  {q:"How does Java avoid diamond problem?",a:["No multiple inheritance for classes","Multiple interfaces allowed","Default methods conflict resolution","All of the above"],c:3,exp:"Java prevents diamond problem by disallowing multiple class inheritance. Interfaces can be multiply inherited; conflicts in default methods must be explicitly resolved by the implementing class."},
  {q:"Which keyword creates anonymous class?",a:["new","anonymous","class","extend"],c:0,exp:"Anonymous classes are created using 'new' followed by a class/interface name and braces containing the implementation. They're used for one-time implementations, especially in event handlers."},
  {q:"Lambda expressions were introduced in:",a:["Java 7","Java 8","Java 9","Java 11"],c:1,exp:"Lambda expressions were introduced in Java 8, enabling functional programming style. They provide a concise way to implement functional interfaces (single abstract method interfaces)."},
  {q:"What replaces anonymous inner class in many cases?",a:["Lambda expression","Anonymous function","Arrow function","All of the above"],c:0,exp:"Lambda expressions provide a more concise alternative to anonymous inner classes for implementing functional interfaces. Instead of verbose anonymous class syntax, use compact lambda syntax like (x, y) -> x + y."},
  {q:"Which is correct lambda syntax?",a:["() -> System.out.println()","x -> x*2","(int a, int b) -> a+b","All are correct"],c:3,exp:"Lambda syntax: (parameters) -> expression or body. Parameters can be typed or inferred. Single parameters don't need parentheses. All three examples show valid lambda syntax for different scenarios."},
  {q:"What is method reference?",a:[":: syntax to refer method","Lambda replacement in some cases","Static method call only","Instance method call only"],c:1,exp:"Method references (::) provide shorthand for lambdas that only call an existing method. ClassName::methodName replaces x -> ClassName.methodName(x). They're more readable than equivalent lambdas."},
  {q:"Which is NOT a type of method reference?",a:["Static","Instance","Constructor","Abstract"],c:3,exp:"Method reference types: Static (ClassName::staticMethod), Instance (object::instanceMethod), Constructor (ClassName::new). There's no 'abstract' method reference type."},
  {q:"What is var keyword used for (Java 10+)?",a:["Local variable type inference","Global variable","Final variable","Static variable"],c:0,exp:"'var' (Java 10+) enables local variable type inference. The compiler determines the type from the initializer. Only for local variables with initializers, not fields, parameters, or return types."},
  {q:"Can records (Java 14+) implement interfaces?",a:["No","Yes","Only marker interfaces","Only functional interfaces"],c:1,exp:"Records can implement interfaces, providing method implementations as needed. They're immutable data carriers with automatic constructor, getters, equals(), hashCode(), and toString()."},
  {q:"What is the main purpose of records?",a:["Immutable data carriers","Mutable data holders","Abstract classes","Functional interfaces"],c:0,exp:"Records (Java 14+) are immutable data carriers. They automatically generate constructors, accessors, equals(), hashCode(), and toString() based on declared fields, reducing boilerplate for simple data classes."}
];